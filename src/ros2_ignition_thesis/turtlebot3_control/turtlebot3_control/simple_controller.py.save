#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
from sensor_msgs.msg import LaserScan
import math

class SimpleTurtleBotController(Node):
    def __init__(self):
        super().__init__('simple_controller')
        
        # Publisher for velocity commands
        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)
        
        # Subscribers for sensors
        self.odom_sub = self.create_subscription(
            Odometry, '/odom', self.odom_callback, 10)
        self.scan_sub = self.create_subscription(
            LaserScan, '/scan', self.scan_callback, 10)
        
        # Timer for control loop (10 Hz)
        self.timer = self.create_timer(0.1, self.control_loop)
        
        # Robot state variables
        self.current_pose = None
        self.min_distance = float('inf')
        
        # Control parameters
        self.linear_speed = 0.2  # m/s
        self.angular_speed = 0.5  # rad/s
        self.obstacle_distance = 0.5  # meters
        
        self.get_logger().info('Simple TurtleBot Controller Started!')
        self.get_logger().info('Robot will move forward and avoid obstacles')
        
    def odom_callback(self, msg):
        """Update robot position from odometry"""
        self.current_pose = msg.pose.pose
        
    def scan_callback(self, msg):
        """Process laser scan data"""
        # Get minimum distance from laser scan
        valid_ranges = [r for r in msg.ranges if not math.isinf(r) and not math.isnan(r)]
        if valid_ranges:
            self.min_distance = min(valid_ranges)
        else:
            self.min_distance = float('inf')
    
    def control_loop(self):
        """Main control loop - runs at 10 Hz"""
        twist = Twist()
        
        # Simple obstacle avoidance behavior
        if self.min_distance < self.obstacle_distance:
            # Obstacle detected - tu            twist.linear
